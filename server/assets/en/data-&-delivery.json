[
  {
    "id": "data-&-delivery-001",
    "version": 1,
    "type": "single",
    "prompt": "You want clients/CDNs to cache for up to 1 hour, allow serving stale content while transparently revalidating, and serve stale for up to 24 hours on errors. Which directive set fits best?",
    "options": [
      { "id": "A", "text": "public, max-age=3600, stale-while-revalidate=60, stale-if-error=86400" },
      { "id": "B", "text": "no-cache, must-revalidate" },
      { "id": "C", "text": "private, max-age=0, no-store" },
      { "id": "D", "text": "public, s-maxage=0, immutable" }
    ],
    "correct": ["A"],
    "explanation": ["Cache for 1 hour via max-age, serve stale during background revalidation via stale-while-revalidate, and allow stale on error via stale-if-error."],
    "explanationIncorrect": [
      "no-cache: Requires revalidation before reuse; no background SWR.",
      "no-store: Disables caching entirely.",
      "immutable with s-maxage=0: Prevents shared caching and discourages revalidation behavior."
    ],
    "source": "RFC 9111 (HTTP Caching); MDN: Cache-Control, stale-while-revalidate/stale-if-error",
    "category": "Data & Networking"
  },
  {
    "id": "data-&-delivery-002",
    "version": 1,
    "type": "single",
    "prompt": "You need uni-directional server→client updates that survive corporate proxies, provide built-in reconnection, and carry a last-seen cursor.",
    "options": [
      { "id": "A", "text": "Server-Sent Events (SSE)" },
      { "id": "B", "text": "WebSocket" },
      { "id": "C", "text": "Long polling with fixed interval" },
      { "id": "D", "text": "HTTP/3 server push" }
    ],
    "correct": ["A"],
    "explanation": ["SSE is HTTP-based, proxy-friendly, auto-reconnects, and supports Last-Event-ID for replay."],
    "explanationIncorrect": [
      "WebSocket: Often blocked by proxies and lacks built-in replay cursor.",
      "Long polling: Inefficient and lacks standardized replay semantics.",
      "Server Push: Discouraged/deprecated for app data."
    ],
    "source": "MDN: Server-Sent Events; WebSocket limitations; IETF discussions on HTTP/2 Push",
    "category": "Data & Networking"
  },
  {
    "id": "data-&-delivery-003",
    "version": 1,
    "type": "single",
    "prompt": "Your client fetches a large NDJSON stream. Users navigate away mid-stream; you want to stop both client processing and server work, and avoid buffering blowups.",
    "options": [
      { "id": "A", "text": "Pass an AbortSignal to fetch and propagate; respect ReadableStream backpressure when piping" },
      { "id": "B", "text": "Client-only timeout; ignore server cancellation" },
      { "id": "C", "text": "Use keepalive: true so the request finishes after unload" },
      { "id": "D", "text": "Ignore reader.cancel() and buffer everything" }
    ],
    "correct": ["A"],
    "explanation": ["AbortSignal allows canceling the fetch and upstream work; backpressure-aware piping prevents memory bloat."],
    "explanationIncorrect": [
      "Timeout-only: Doesn’t reliably stop server work.",
      "keepalive true: For small fire-and-forget; prevents timely cancellation.",
      "Ignore cancel/backpressure: Risks memory growth and wasted processing."
    ],
    "source": "WHATWG Fetch (AbortSignal); MDN: Streams API & backpressure",
    "category": "Data & Networking"
  },
  {
    "id": "data-&-delivery-004",
    "version": 1,
    "type": "single",
    "prompt": "You want CDN caching of GraphQL responses that vary by variables and user locale. What setup is sound?",
    "options": [
      { "id": "A", "text": "Persisted queries over GET; cache public, s-maxage=300, stale-while-revalidate=30; include persisted id and variables plus Accept-Language in the cache key" },
      { "id": "B", "text": "POST for everything; intermediaries will cache with max-age" },
      { "id": "C", "text": "GET but strip the query string in the CDN" },
      { "id": "D", "text": "GET and cache on URL path only, ignoring locale" }
    ],
    "correct": ["A"],
    "explanation": ["GET + persisted queries enable HTTP caching; keys must include variables and locale to avoid variant bleed."],
    "explanationIncorrect": [
      "POST-only: Intermediaries typically don’t cache POST responses.",
      "Strip query: Loses variable discrimination; serves wrong content.",
      "Ignore locale: Mixes language variants in cache."
    ],
    "source": "Apollo/APQ persisted queries; RFC 9111: Vary and cache keys; CDN cache key configuration",
    "category": "Data & Networking"
  },
  {
    "id": "data-&-delivery-005",
    "version": 1,
    "type": "multi",
    "prompt": "Which failures are reasonable to retry with backoff + jitter (respecting Retry-After)?",
    "options": [
      { "id": "A", "text": "408 Request Timeout" },
      { "id": "B", "text": "429 Too Many Requests" },
      { "id": "C", "text": "502/503/504 gateway/service errors" },
      { "id": "D", "text": "401 Unauthorized or 422 Unprocessable Entity" }
    ],
    "correct": ["A", "B", "C"],
    "explanation": ["Transient conditions like timeouts, rate limits, and gateway/service errors are appropriate for backoff + jitter retries."],
    "explanationIncorrect": [
      "Auth/semantic errors: Require credential changes or input fixes, not blind retries."
    ],
    "source": "RFC 9110/9111; Cloud vendor retry guidance (jitter, backoff)",
    "category": "Data & Networking"
  },
  {
    "id": "data-&-delivery-006",
    "version": 1,
    "type": "multi",
    "prompt": "How do you enable “no body if unchanged” semantics for a list endpoint?",
    "options": [
      { "id": "A", "text": "Return a strong ETag and accept If-None-Match" },
      { "id": "B", "text": "Return Last-Modified and accept If-Modified-Since" },
      { "id": "C", "text": "Ask the client to send If-Range without Range requests" },
      { "id": "D", "text": "Set Cache-Control: no-store for safety" }
    ],
    "correct": ["A", "B"],
    "explanation": ["Conditional requests via ETag/If-None-Match or Last-Modified/If-Modified-Since allow 304 Not Modified without a body."],
    "explanationIncorrect": [
      "If-Range: Applies to partial content, not standard conditional GET.",
      "no-store: Disables caching and validation entirely."
    ],
    "source": "RFC 9110 (validators); MDN: ETag and Last-Modified",
    "category": "Data & Networking"
  },
  {
    "id": "data-&-delivery-007",
    "version": 1,
    "type": "multi",
    "prompt": "HTTP/3/QUIC: which statements are correct?",
    "options": [
      { "id": "A", "text": "Independent streams avoid TCP head-of-line blocking at the transport level" },
      { "id": "B", "text": "QUIC uses UDP with mandatory TLS 1.3; supports 0-RTT with replay risks for unsafe requests" },
      { "id": "C", "text": "Server Push is widely recommended for app data delivery in H3" },
      { "id": "D", "text": "QUIC ensures lower latency than HTTP/2 in every scenario" }
    ],
    "correct": ["A", "B"],
    "explanation": ["QUIC multiplexing mitigates HoL at the transport; TLS 1.3 and optional 0-RTT are integral to H3 with replay caveats."],
    "explanationIncorrect": [
      "Push discouraged: Server Push is deprecated/ill-advised for general application data.",
      "No universal wins: Performance depends on network and workload; H3 isn’t always faster than H2."
    ],
    "source": "RFC 9000/9114; Industry guidance on HTTP/2 Push deprecation",
    "category": "Edge & Protocols"
  },
  {
    "id": "data-&-delivery-008",
    "version": 1,
    "type": "multi",
    "prompt": "Early Hints (103): what is correct usage?",
    "options": [
      { "id": "A", "text": "Send 103 Early Hints with Link: rel=preload for critical resources while the origin prepares the final response" },
      { "id": "B", "text": "Send parts of the HTML body in the 103 response" },
      { "id": "C", "text": "103 works only with HTTP/2" },
      { "id": "D", "text": "If unsupported, clients ignore it harmlessly" }
    ],
    "correct": ["A", "D"],
    "explanation": ["Early Hints allows header-only hints for parallelization and degrades gracefully when unsupported."],
    "explanationIncorrect": [
      "Body in 103: Early Hints carries headers only.",
      "H2-only: It is protocol-agnostic if intermediaries support it."
    ],
    "source": "RFC 8297 (Early Hints); CDN vendor documentation",
    "category": "Edge & Protocols"
  },
  {
    "id": "data-&-delivery-009",
    "version": 1,
    "type": "multi",
    "prompt": "0-RTT in TLS 1.3: safe usage patterns?",
    "options": [
      { "id": "A", "text": "Restrict to idempotent routes and guard handlers against replay" },
      { "id": "B", "text": "Accept for any method to maximize speed" },
      { "id": "C", "text": "Disable 0-RTT if your app cannot tolerate replay, or gate it by path" },
      { "id": "D", "text": "Store and compare anti-replay tokens on the server" }
    ],
    "correct": ["A", "C", "D"],
    "explanation": ["Use 0-RTT only for idempotent requests, consider disabling or scoping it, and implement anti-replay measures server-side."],
    "explanationIncorrect": [
      "Unrestricted methods: Risk duplicate side effects on replay."
    ],
    "source": "RFC 8446 (TLS 1.3) 0-RTT guidance; QUIC best practices",
    "category": "Edge & Protocols"
  },
  {
    "id": "data-&-delivery-010",
    "version": 1,
    "type": "multi",
    "prompt": "Building robust CDN cache keys",
    "options": [
      { "id": "A", "text": "Include path plus only relevant query params; ignore noise (e.g., utm_*); vary on locale headers as needed" },
      { "id": "B", "text": "Always include cookies in the cache key to maximize correctness" },
      { "id": "C", "text": "Normalize URLs (trailing slashes, case) to avoid duplicate entries" },
      { "id": "D", "text": "Use a single global key regardless of device/locale to increase hit rate" }
    ],
    "correct": ["A", "C"],
    "explanation": [
      "Precise keying: Limiting the cache key to path and truly variant-driving params (and appropriate Vary like locale) prevents variant bleed and boosts hit rate.",
      "Normalization: Canonicalizing URLs (e.g., trailing slash, case) avoids cache fragmentation from semantically identical URLs."
    ],
    "explanationIncorrect": [
      "Cookies in key: Cookies often personalize responses and explode the key space, collapsing cache efficiency.",
      "Single global key: A one-size key ignores device/locale variants and can serve incorrect content."
    ],
    "source": "CDN best practices on cache keys and normalization; RFC 9111 (Vary, cache keys)",
    "category": "Edge & Protocols"
  },
  {
    "id": "data-&-delivery-011",
    "version": 1,
    "type": "multi",
    "prompt": "Origin shielding and failure policies",
    "options": [
      { "id": "A", "text": "Use an origin shield/central POP to coalesce misses and protect the origin" },
      { "id": "B", "text": "Configure stale-while-revalidate and stale-if-error to ride through spikes/outages" },
      { "id": "C", "text": "Disable negative caching of 5xx so every error re-hammers origin" },
      { "id": "D", "text": "Purge everything on each deploy to be safe" }
    ],
    "correct": ["A", "B"],
    "explanation": [
      "Resilience patterns: Shielding reduces origin load, and stale directives sustain service through spikes and outages."
    ],
    "explanationIncorrect": [
      "No negative caching: Causes thundering herds.",
      "Purge-all: Destroys locality and increases cold starts."
    ],
    "source": "CDN best practices (origin shield, stale policies)",
    "category": "Edge & Protocols"
  },
  {
    "id": "data-&-delivery-012",
    "version": 1,
    "type": "multi",
    "prompt": "Compression & content negotiation",
    "options": [
      { "id": "A", "text": "Serve Brotli (br) for text over HTTPS with gzip fallback; negotiate via Accept-Encoding" },
      { "id": "B", "text": "Recompress JPEG/MP4 for “extra” savings" },
      { "id": "C", "text": "Set Vary: Accept-Encoding and cache per encoding" },
      { "id": "D", "text": "Precompress static assets and let the CDN pick encoding" }
    ],
    "correct": ["A", "C", "D"],
    "explanation": [
      "Negotiated compression: Brotli/gzip with correct Vary and precompressed assets reduces transfer size and maintains cache correctness."
    ],
    "explanationIncorrect": [
      "Double compression: Recompressing already-compressed media wastes CPU and can increase size."
    ],
    "source": "MDN: Content-Encoding/Accept-Encoding; CDN static compression guidance",
    "category": "Edge & Protocols"
  },
  {
    "id": "data-&-delivery-013",
    "version": 1,
    "type": "multi",
    "prompt": "Connection reuse & coalescing",
    "options": [
      { "id": "A", "text": "H2/H3 multiplex many requests per connection" },
      { "id": "B", "text": "Coalescing can reuse a connection across hostnames sharing cert SAN/IP per TLS rules" },
      { "id": "C", "text": "Domain sharding should always be used in H2/H3" },
      { "id": "D", "text": "Preconnect to critical origins to hide handshakes" }
    ],
    "correct": ["A", "B", "D"],
    "explanation": [
      "Fewer setups: Multiplexing, coalescing, and preconnect reduce connection overhead and speed up requests."
    ],
    "explanationIncorrect": [
      "Legacy practice: Sharding is an HTTP/1 workaround that harms H2/H3 compression and multiplexing."
    ],
    "source": "HTTP/2 & HTTP/3 performance best practices; MDN: preconnect; connection coalescing",
    "category": "Edge & Protocols"
  },
  {
    "id": "data-&-delivery-014",
    "version": 1,
    "type": "single",
    "prompt": "Predictive navigation with minimal risk",
    "options": [
      { "id": "A", "text": "Use Speculation Rules to prefetch likely next documents on weak signals; prerender only on strong intent (hover/mousedown)" },
      { "id": "B", "text": "Preload all routes’ JS/CSS at TTFB" },
      { "id": "C", "text": "Use <link rel=\"prefetch\"> for the current route’s LCP image" },
      { "id": "D", "text": "Always prerender cross-origin; the destination will accept it" }
    ],
    "correct": ["A"],
    "explanation": [
      "Selective prediction: Cheap prefetch for likely next pages and high-confidence prerendering minimize waste and side effects."
    ],
    "explanationIncorrect": [
      "Over-preload: Bulk preloading hurts LCP/TTI by competing with critical resources.",
      "Wrong hint: Current-route LCP should be preload/fetchpriority, not prefetch.",
      "Missing opt-in: Cross-origin prerender requires explicit destination support."
    ],
    "source": "web.dev: Speculation Rules (prefetch/prerender); Priority Hints",
    "category": "Speculation & Loading Priorities"
  },
  {
    "id": "data-&-delivery-015",
    "version": 1,
    "type": "multi",
    "prompt": "Preload vs prefetch vs preconnect",
    "options": [
      { "id": "A", "text": "preload = fetch now for this navigation; render-critical" },
      { "id": "B", "text": "prefetch = fetch soon for a future navigation at low priority" },
      { "id": "C", "text": "preconnect = warm TCP/TLS (and optionally DNS)" },
      { "id": "D", "text": "dns-prefetch = early DNS resolve when preconnect isn’t possible" }
    ],
    "correct": ["A", "B", "C", "D"],
    "explanation": [
      "Right hint, right time: Preload is for current critical resources, prefetch for future ones, preconnect warms connections, and dns-prefetch only resolves DNS."
    ],
    "explanationIncorrect": [],
    "source": "MDN: preload, prefetch, preconnect, dns-prefetch; web.dev: Resource hints",
    "category": "Speculation & Loading Priorities"
  },
  {
    "id": "data-&-delivery-016",
    "version": 1,
    "type": "single",
    "prompt": "Priority hints on the LCP image",
    "options": [
      { "id": "A", "text": "Set fetchpriority=\"high\" on the hero <img>; pair with decoding=\"async\" and explicit dimensions" },
      { "id": "B", "text": "Use loading=\"lazy\" on the hero to save bandwidth" },
      { "id": "C", "text": "Set importance=\"high\" on a below-the-fold image" },
      { "id": "D", "text": "Rely on browser heuristics alone" }
    ],
    "correct": ["A"],
    "explanation": [
      "Boost the hero: Explicit priority and sizing accelerate LCP and reduce CLS risk."
    ],
    "explanationIncorrect": [
      "Lazy LCP: Defers the most important image and delays paint.",
      "Misprioritization: Marking non-critical images as high steals bandwidth from critical assets.",
      "Heuristics only: Browsers can misclassify; hints improve reliability."
    ],
    "source": "web.dev: Priority Hints & LCP; MDN: loading, decoding, fetchpriority",
    "category": "Speculation & Loading Priorities"
  },
  {
    "id": "data-&-delivery-017",
    "version": 1,
    "type": "multi",
    "prompt": "Speculation Rules & cancellation semantics",
    "options": [
      { "id": "A", "text": "Prerenders run hidden; activation is instant if not canceled" },
      { "id": "B", "text": "Gate/defer side effects (analytics with credentials) until activation" },
      { "id": "C", "text": "Browsers may cancel prerenders under memory/CPU pressure" },
      { "id": "D", "text": "A canceled prerender must not leave user-visible side effects" }
    ],
    "correct": ["A", "B", "C", "D"],
    "explanation": [
      "Safe prerendering: Hidden execution, potential cancellation, and strict side-effect discipline are core invariants; activation should be instant and side-effect free."
    ],
    "explanationIncorrect": [],
    "source": "web.dev: Prerendering & activation; Chrome prerender restrictions",
    "category": "Speculation & Loading Priorities"
  },
  {
    "id": "data-&-delivery-018",
    "version": 1,
    "type": "multi",
    "prompt": "Avoid double-downloads and cache misses",
    "options": [
      { "id": "A", "text": "Make prefetched docs/assets cacheable (e.g., public, max-age/stale-while-revalidate) so navigation reuses them" },
      { "id": "B", "text": "Avoid no-store on resources you intend to reuse" },
      { "id": "C", "text": "For authenticated areas, match credential model; prerender can beat generic prefetch" },
      { "id": "D", "text": "Strip tracking params from predicted URLs to improve key reuse" }
    ],
    "correct": ["A", "B", "C", "D"],
    "explanation": [
      "Reuse-friendly speculation: Cacheable prefetch, clean keys, and matching credentials ensure predicted resources are reused; prerender fits credentialed flows."
    ],
    "explanationIncorrect": [],
    "source": "RFC 9111 (HTTP caching); web.dev: Prefetching best practices",
    "category": "Speculation & Loading Priorities"
  },
  {
    "id": "data-&-delivery-019",
    "version": 1,
    "type": "multi",
    "prompt": "Load JS without harming LCP",
    "options": [
      { "id": "A", "text": "Mark non-critical scripts defer; split by route; prefetch likely-next chunks" },
      { "id": "B", "text": "Inline a tiny bootstrap; keep heavy logic async" },
      { "id": "C", "text": "Use async for scripts that don’t rely on order" },
      { "id": "D", "text": "Inline large libraries to reduce requests" }
    ],
    "correct": ["A", "B", "C"],
    "explanation": [
      "Non-blocking delivery: defer/async and code-splitting preserve rendering; a small inline bootstrap is fine, but heavy logic should remain async."
    ],
    "explanationIncorrect": [
      "HTML bloat: Inlining large libraries inflates HTML, slows parsing, and harms LCP."
    ],
    "source": "web.dev: Optimize JavaScript loading; MDN: defer vs async",
    "category": "Speculation & Loading Priorities"
  },
  {
    "id": "data-&-delivery-020",
    "version": 1,
    "type": "multi",
    "prompt": "Diagnose misprioritized requests",
    "options": [
      { "id": "A", "text": "Use DevTools Priority/waterfall to verify computed priorities and hint effects" },
      { "id": "B", "text": "Confirm the LCP element via PerformanceObserver and correlate with request timing" },
      { "id": "C", "text": "Check for immutable/no-transform mismatches on critical assets" },
      { "id": "D", "text": "Trust a single Lighthouse pass" }
    ],
    "correct": ["A", "B", "C"],
    "explanation": [
      "Evidence-driven triage: DevTools and PerformanceObserver confirm which resource is LCP and how hints map to network behavior; headers like immutable can block intended prioritization."
    ],
    "explanationIncorrect": [
      "Lab-only optimism: A single Lighthouse run can miss real-world inversions and regressions."
    ],
    "source": "Chrome DevTools (Priority/Network); MDN: PerformanceObserver (LCP)",
    "category": "Speculation & Loading (Deep Diagnostics & Edge)"
  },
  {
    "id": "data-&-delivery-021",
    "version": 1,
    "type": "multi",
    "prompt": "Edge/CDN interplay with hints",
    "options": [
      { "id": "A", "text": "Propagate 103 Early Hints with Link: rel=preload for critical CSS/LCP image" },
      { "id": "B", "text": "Normalize cache keys to avoid fragmenting prefetched/prerendered variants" },
      { "id": "C", "text": "Ensure CDN honors Vary on Accept-Language/Accept-Encoding" },
      { "id": "D", "text": "Strip all Vary headers to boost hit rate" }
    ],
    "correct": ["A", "B", "C"],
    "explanation": [
      "Hint-aware edge: Early Hints accelerate critical fetches; normalized keys and correct Vary handling maintain correctness and reuse."
    ],
    "explanationIncorrect": [
      "Variant corruption: Removing Vary serves incorrect content across languages/encodings."
    ],
    "source": "RFC 8297 (Early Hints); RFC 9111 (Vary); CDN documentation",
    "category": "Speculation & Loading (Deep Diagnostics & Edge)"
  },
  {
    "id": "data-&-delivery-022",
    "version": 1,
    "type": "multi",
    "prompt": "When not to prerender",
    "options": [
      { "id": "A", "text": "Pages with sensitive side effects (logout, destructive GET-on-load)" },
      { "id": "B", "text": "Heavily personalized dashboards with leakage risk" },
      { "id": "C", "text": "Pages with large memory footprints on constrained devices" },
      { "id": "D", "text": "Static, likely-next articles" }
    ],
    "correct": ["A", "B", "C"],
    "explanation": [
      "Prerender pitfalls: Destructive actions, personalization, and heavy memory use can leak state or waste resources when prerendered."
    ],
    "explanationIncorrect": [
      "Static content: Likely-next, static pages can be safe candidates for prefetch/prerender with proper guardrails."
    ],
    "source": "web.dev: Prerendering caveats and safeguards",
    "category": "Speculation & Loading (Deep Diagnostics & Edge)"
  },
  {
    "id": "data-&-delivery-023",
    "version": 1,
    "type": "multi",
    "prompt": "Prefetching data APIs vs documents",
    "options": [
      { "id": "A", "text": "Prefer document prefetch for navigations; for SPA data, warm SW/Query cache keyed by the next route’s query" },
      { "id": "B", "text": "Ensure credentials mode matches eventual use (include/same-origin)" },
      { "id": "C", "text": "Avoid prefetching volatile APIs with short TTL unless you can revalidate cheaply" },
      { "id": "D", "text": "Use immutable for API JSON to prevent revalidation" }
    ],
    "correct": ["A", "B", "C"],
    "explanation": [
      "Right target, right cache: Document prefetch maps to navigation reuse; API warming should respect credentials and volatility to avoid staleness."
    ],
    "explanationIncorrect": [
      "Overstale directive: immutable on changing API data risks serving stale responses indefinitely."
    ],
    "source": "RFC 9111 caching directives; TanStack Query caching patterns",
    "category": "Speculation & Loading (Deep Diagnostics & Edge)"
  },
  {
    "id": "data-&-delivery-024",
    "version": 1,
    "type": "multi",
    "prompt": "Speculation Rules targeting",
    "options": [
      { "id": "A", "text": "Target viewport links/patterns; combine with interaction signals (hover/mousedown) for prerender" },
      { "id": "B", "text": "Limit concurrency and total budget" },
      { "id": "C", "text": "Use allow/deny-lists (e.g., exclude ?logout=true)" },
      { "id": "D", "text": "Apply rules indiscriminately to all anchors" }
    ],
    "correct": ["A", "B", "C"],
    "explanation": [
      "Budgeted precision: Narrow targeting, budgets, and guardlists capture wins while controlling cost and avoiding unsafe routes."
    ],
    "explanationIncorrect": [
      "Spray-and-pray: Indiscriminate speculation wastes bandwidth and can trigger side effects."
    ],
    "source": "web.dev: Speculation Rules API (selectors, budgets, allow/deny lists)",
    "category": "Speculation & Loading (Deep Diagnostics & Edge)"
  },
  {
    "id": "data-&-delivery-025",
    "version": 1,
    "type": "multi",
    "prompt": "Measuring value from speculation",
    "options": [
      { "id": "A", "text": "Compare p75 TTI/first-interaction latency and nav→first-paint deltas for predicted vs non-predicted flows" },
      { "id": "B", "text": "Track speculation hit rate and cancel rate; prune low-activation rules" },
      { "id": "C", "text": "Attribute wins to rule IDs in telemetry" },
      { "id": "D", "text": "Rely on Lighthouse score changes" }
    ],
    "correct": ["A", "B", "C"],
    "explanation": [
      "Field-based ROI: Measuring real-user KPIs and rule-level activation/cancellation reveals which predictions help and where to prune."
    ],
    "explanationIncorrect": [
      "Lab-only signal: Lighthouse scores don’t capture journey-level prediction effects in the field."
    ],
    "source": "RUM best practices; web.dev: measuring navigation performance",
    "category": "Speculation & Loading (Deep Diagnostics & Edge)"
  },
  {
    "id": "data-&-delivery-026",
    "version": 1,
    "type": "single",
    "prompt": "Transport for low-latency, two-way P2P collab behind NATs",
    "options": [
      { "id": "A", "text": "WebRTC DataChannels with STUN/TURN; use SFU/relay for groups" },
      { "id": "B", "text": "WebSocket over TLS with server fan-out" },
      { "id": "C", "text": "SSE + POST back" },
      { "id": "D", "text": "WebTransport unidirectional streams" }
    ],
    "correct": ["A"],
    "explanation": [
      "NAT-traversing P2P: WebRTC DataChannels provide low-latency peer-to-peer transport with STUN/TURN, and SFUs/relays scale groups."
    ],
    "explanationIncorrect": [
      "Server hub: WebSockets are client↔server and don’t provide P2P semantics.",
      "One-way: SSE lacks client→server channel and isn’t suitable for P2P.",
      "Client-server QUIC: WebTransport is not P2P and not limited to uni streams."
    ],
    "source": "MDN: WebRTC DataChannel; STUN/TURN; WebTransport overview",
    "category": "Real-Time UX"
  },
  {
    "id": "data-&-delivery-027",
    "version": 1,
    "type": "single",
    "prompt": "Reconnect/backoff without stampede",
    "options": [
      { "id": "A", "text": "Exponential backoff with full jitter; caps; reset on success" },
      { "id": "B", "text": "Linear backoff without jitter" },
      { "id": "C", "text": "Immediate tight retries until success" },
      { "id": "D", "text": "Fixed 5s interval always" }
    ],
    "correct": ["A"],
    "explanation": [
      "Herd avoidance: Exponential backoff with jitter and caps prevents synchronization storms and balances recovery speed and load."
    ],
    "explanationIncorrect": [
      "Synchronized retries: Linear/fixed intervals align clients and amplify load.",
      "Hammering: Tight loops overwhelm services and drain batteries."
    ],
    "source": "AWS Architecture Blog on backoff+jitter; IETF guidance",
    "category": "Real-Time UX"
  },
  {
    "id": "data-&-delivery-028",
    "version": 1,
    "type": "single",
    "prompt": "“Exactly once” on at-least-once streams (the illusion)",
    "options": [
      { "id": "A", "text": "Monotonic eventId/cursor; idempotent dedupe client-side; replay from last acknowledged" },
      { "id": "B", "text": "Trust TCP to avoid duplicates" },
      { "id": "C", "text": "Use timestamps as IDs and drop older" },
      { "id": "D", "text": "Accept duplicates and let the UI double-render" }
    ],
    "correct": ["A"],
    "explanation": [
      "Idempotency keys: Stable IDs, deduplication, and resumable cursors emulate exactly-once atop at-least-once delivery."
    ],
    "explanationIncorrect": [
      "Transport-only guarantees: TCP order doesn’t handle app-level retries/reconnects.",
      "Unstable identifiers: Timestamps collide and reorder under clock skew.",
      "State corruption: Double-rendering duplicates user-visible actions."
    ],
    "source": "SSE Last-Event-ID pattern; stream processing idempotency practices",
    "category": "Real-Time UX"
  },
  {
    "id": "data-&-delivery-029",
    "version": 1,
    "type": "single",
    "prompt": "Presence at scale",
    "options": [
      { "id": "A", "text": "Heartbeats with TTL; eventual consistency; central pub/sub (e.g., Redis) for fan-out" },
      { "id": "B", "text": "Require strong consistency; block UI until exact counts" },
      { "id": "C", "text": "Emit one update per user action to all subscribers" },
      { "id": "D", "text": "Only fixed-interval polling" }
    ],
    "correct": ["A"],
    "explanation": [
      "Ephemeral truth: Heartbeat+TTL with eventual consistency and a shared pub/sub backbone scales presence without blocking UX."
    ],
    "explanationIncorrect": [
      "Strong consistency: Expensive and degrades responsiveness.",
      "Chatty floods: Per-action fan-out doesn’t scale.",
      "Rigid polling: Wastes resources and feels laggy at low activity."
    ],
    "source": "Slack/Discord engineering posts on presence; realtime system patterns",
    "category": "Real-Time UX"
  },
  {
    "id": "data-&-delivery-030",
    "version": 1,
    "type": "single",
    "prompt": "Ordering & causality in collaborative edits",
    "options": [
      { "id": "A", "text": "Use CRDT/OT with Lamport/vector clocks or causal metadata" },
      { "id": "B", "text": "Assume server arrival order equals causality" },
      { "id": "C", "text": "Drop late events (LWW)" },
      { "id": "D", "text": "Lock the document so only one writes at a time" }
    ],
    "correct": ["A"],
    "explanation": [
      "Conflict-free merging: CRDT/OT with causal metadata reconciles concurrent edits without locks and preserves intent."
    ],
    "explanationIncorrect": [
      "Arrival ≠ causality: Network reordering breaks this assumption.",
      "Data loss: Last-writer-wins discards valid edits.",
      "Collaboration-killing: Locks prevent real-time co-editing."
    ],
    "source": "CRDT literature (Shapiro et al.); OT references; distributed systems causality",
    "category": "Real-Time UX"
  },
  {
    "id": "data-&-delivery-031",
    "version": 1,
    "type": "single",
    "prompt": "Battery-friendly “typing” indicators",
    "options": [
      { "id": "A", "text": "Coalesce locally; send start/stop with inactivity timeout; rate-limit" },
      { "id": "B", "text": "Send every keypress" },
      { "id": "C", "text": "Fixed 5s interval regardless of activity" },
      { "id": "D", "text": "Server polls clients" }
    ],
    "correct": ["A"],
    "explanation": [
      "Lightweight presence: Coalescing, idle timeouts, and rate limits keep indicators responsive without excessive network/battery cost."
    ],
    "explanationIncorrect": [
      "Noisy chatter: Per-keystroke updates are wasteful.",
      "Activity-agnostic: Fixed intervals ignore real usage patterns.",
      "Reverse polling: Server polling adds lag and load."
    ],
    "source": "Realtime UX design patterns; general rate-limiting guidance",
    "category": "Real-Time UX"
  },
  {
    "id": "data-&-delivery-032",
    "version": 1,
    "type": "multi",
    "prompt": "Make a CSR-heavy app discoverable",
    "options": [
      { "id": "A", "text": "SSR/SSG key routes (or crawl-prerender) so HTML includes content/meta;" },
      { "id": "B", "text": "Rely on engines to always run JS" },
      { "id": "C", "text": "Unique <title>, meta description, canonical per route in server HTML" },
      { "id": "D", "text": "Hashbang #! URLs for special handling" }
    ],
    "correct": ["A", "C"],
    "explanation": [
      "Crawler-ready HTML: Server-rendered content/meta and unique titles/canonicals per route drive reliable indexing and sharing."
    ],
    "explanationIncorrect": [
      "JS dependency: Not all crawlers execute JS reliably or timely.",
      "Legacy pattern: Hashbang handling is deprecated and discouraged."
    ],
    "source": "Google/Search Central: JavaScript SEO; web.dev: Rendering on the Web",
    "category": "SEO & Discovery for Modern Apps"
  },
  {
    "id": "data-&-delivery-033",
    "version": 1,
    "type": "multi",
    "prompt": "Product structured data",
    "options": [
      { "id": "A", "text": "JSON-LD @type: Product with name, image, description, sku, offers (price, priceCurrency, availability)" },
      { "id": "B", "text": "Include aggregateRating/review only if actually shown" },
      { "id": "C", "text": "Duplicate JSON-LD and Microdata with differing values" },
      { "id": "D", "text": "Stable @id matching the canonical URL" }
    ],
    "correct": ["A", "B", "D"],
    "explanation": [
      "Truthful markup: Complete JSON-LD aligned with on-page content and stable identifiers improves eligibility for rich results."
    ],
    "explanationIncorrect": [
      "Conflicting annotations: Divergent values across formats cause errors or suppression."
    ],
    "source": "Google: Product structured data guidelines; Schema.org Product",
    "category": "SEO & Discovery for Modern Apps"
  },
  {
    "id": "data-&-delivery-034",
    "version": 1,
    "type": "multi",
    "prompt": "Internationalization & alternate discovery",
    "options": [
      { "id": "A", "text": "hreflang pairs (including self-referential) + x-default for a generic page" },
      { "id": "B", "text": "Auto-redirect on IP without a locale switcher" },
      { "id": "C", "text": "Canonical points to the page’s own URL (not a global)" },
      { "id": "D", "text": "Locale-specific sitemaps or hreflang in sitemaps" }
    ],
    "correct": ["A", "C", "D"],
    "explanation": [
      "Locale correctness: Proper hreflang maps, self-canonicals, and locale-aware sitemaps help search engines serve the right language/region."
    ],
    "explanationIncorrect": [
      "Forced redirection: IP-based redirects can trap crawlers and users; always provide a switcher."
    ],
    "source": "Google: hreflang guidelines; sitemaps with hreflang",
    "category": "SEO & Discovery for Modern Apps"
  },
  {
    "id": "data-&-delivery-035",
    "version": 1,
    "type": "multi",
    "prompt": "Facets, parameters, and crawl budget",
    "options": [
      { "id": "A", "text": "Canonicalize filter/sort variants to a clean canonical when content is essentially the same" },
      { "id": "B", "text": "noindex, follow for infinite/facet pages that shouldn’t be indexed" },
      { "id": "C", "text": "Strip tracking params (utm_*) at the edge and from cache/canonicals" },
      { "id": "D", "text": "Rely only on robots.txt Disallow for already indexed params" }
    ],
    "correct": ["A", "B", "C"],
    "explanation": [
      "Duplicate control: Canonicals, selective noindex, and parameter hygiene prevent index bloat and preserve crawl budget."
    ],
    "explanationIncorrect": [
      "Index persistence: robots.txt stops crawling but doesn’t de-index existing URLs; use noindex/canonicals."
    ],
    "source": "Google: Canonicalization & parameter handling guidance",
    "category": "SEO & Discovery for Modern Apps"
  },
  {
    "id": "data-&-delivery-036",
    "version": 1,
    "type": "multi",
    "prompt": "Sitemaps that scale",
    "options": [
      { "id": "A", "text": "≤50,000 URLs per sitemap (≤50 MB); use a sitemap index; only 200-OK canonicals; include lastmod" },
      { "id": "B", "text": "Regenerate everything daily regardless of change" },
      { "id": "C", "text": "Include both HTTP and HTTPS variants" },
      { "id": "D", "text": "Keep a stable sitemap URL and ping Search Console on major updates" }
    ],
    "correct": ["A", "D"],
    "explanation": [
      "Protocol compliance: Respect limits, include only canonical 200s, update lastmod and ping on meaningful changes for reliable discovery."
    ],
    "explanationIncorrect": [
      "Wasteful churn: Full daily regeneration is unnecessary; incremental updates suffice.",
      "Duplicate variants: Listing HTTP+HTTPS creates canonical confusion."
    ],
    "source": "sitemaps.org protocol; Google Search Central: Sitemaps best practices",
    "category": "SEO & Discovery for Modern Apps"
  },
  {
    "id": "data-&-delivery-037",
    "version": 1,
    "type": "multi",
    "prompt": "Social sharing (OG/Twitter) for SPA routes",
    "options": [
      { "id": "A", "text": "Server HTML must include route-specific Open Graph/Twitter meta; most scrapers don’t run JS" },
      { "id": "B", "text": "Client-side meta updates are sufficient" },
      { "id": "C", "text": "Pre-generate social images per route and expose a stable og:image" },
      { "id": "D", "text": "One generic og:* for all pages" }
    ],
    "correct": ["A", "C"],
    "explanation": [
      "Share-ready HTML: Server-rendered meta and stable per-route images yield accurate previews and better CTR."
    ],
    "explanationIncorrect": [
      "JS reliance: Many scrapers don’t execute client-side DOM mutations.",
      "Undifferentiated tags: Generic OG undermines relevance and click-through."
    ],
    "source": "Facebook/Twitter crawler docs; SSR-for-sharing guidance",
    "category": "SEO & Discovery for Modern Apps"
  }
]
